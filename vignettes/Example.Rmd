---
title: "Examples"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(quoll)
library(DiagrammeR)
```

## Partial Inverses

The `quoll` package primarily provides graph theoretic methods for deriving individual elements of
the inverse or adjoint of a matrix from its sign pattern.

Consider the block matrix
$$
X = 
\begin{bmatrix}
-a_{11} & \hphantom{-}a_{12} & \hphantom{-}0 & \hphantom{-}0 \\
\hphantom{-}a_{21} & -a_{22} & \hphantom{-}0 & \hphantom{-}0 \\
\hphantom{-}0 & \hphantom{-}0 & \hphantom{-}a_{33} & -a_{34} \\
\hphantom{-}0 & \hphantom{-}0 & -a_{43} & \hphantom{-}a_{44}
\end{bmatrix}
$$
as the elementwise product $X = S \odot A$ of a sign matrix $S$ and a weight matrix $A$
$$
A = 
\begin{bmatrix}
a_{11} & a_{12} & 0 & 0 \\
a_{21} & a_{22} & 0 & 0 \\
0 & 0 & a_{33} & a_{34} \\
0 & 0 & a_{43} & a_{44}
\end{bmatrix}
\qquad
S = 
\begin{bmatrix}
-1 & \hphantom{-}1 & \hphantom{-}0 & \hphantom{-}0 \\
\hphantom{-}1 & -1 & \hphantom{-}0 & \hphantom{-}0 \\
\hphantom{-}0 & \hphantom{-}0 & \hphantom{-}1 & -1 \\
\hphantom{-}0 & \hphantom{-}0 & -1 & \hphantom{-}1
\end{bmatrix}
$$

Given the sign matrix $S$, the `partial` function can derive expressions for individual elements of 
the inverse $R=X^{-1}$ in terms of the elements of the weight matrix $A$.  Symbolic expressions for
these elements can be rendered in LaTeX with `partial_latex`;  to generate the elements
$r_{2,2}$ and $r_{4,3}$
```{r,results='asis'}
S <- matrix(c(-1,1,0,0,1,-1,0,0,0,0,1,-1,0,0,-1,1),4,4)
p <- partial(S,c(2,4),c(2,3))
cat("$$",partial_latex(p,type="inv"),"$$",sep="\n")
```
R code to evaluate the (partial) inverse matrix given $A$ can be generated with `partial_R`:
```{r}
inv <- eval(str2lang(partial_R(p,type="inv")))
## Random weight matrix
A <- matrix(runif(length(S)),nrow(S),ncol(S),dimnames=dimnames(S))
## Numerical inverse
X <- S*A
solve(X)
## quoll
inv(A)
```

By default these functions generate expressions for elements of the inverse matrix; expressions for 
the elements of the adjoint matrix are generated when when `type="adj"`.

If only the determinant is required, LaTeX or R expressions for the determinant can be generated 
from a partial object with the `determinant_latex` or `determinant_R` functions.
```{r,results='asis'}
cat("$$",determinant_latex(p),"$$",sep="\n")
```

The complexity of the expressions generated by these functions is determined by the number of cycles 
in the weighted directed graph generated by `S`.  The directed graph can be visualized with 
`digraph_diagram`.
```{r}
grViz(digraph_diagram(S))
```
and the cycles in the digraph can be found with `directed_cycles`.
```{r}
directed_cycles(S)
```

For sparse matrices with few cycles, the R code generated by `partial_R` can be as fast as using 
`solve` directly, particularly if only a few elements of the inverse matrix are required.  For
larger problems, C++ code for the inverse or adjoint for use with `Rcpp::cppFunction` can be 
generated with `partial_cpp`.
```{r,results='asis'}
cat("``` {.cpp}",partial_cpp(p,type="inv"),"```",sep="\n")
```


## Characteristic Polynomial

The  characteristic polynomial of the matrix can be generated with `cpoly`. This function returns an 
intermediate object which can be rendered as LaTeX for the polynomial or R code for the polynomial 
coefficients.
```{r,results='asis'}
cp <- cpoly(X,factor=TRUE)
cat("$$",cpoly_latex(cp),"$$",sep="\n")
```
If `factor=TRUE`, the characteristic polynomial is factored into components generated by the
strongly connected components of the weighted digraph corresponding to `S`.


## Qualitative Analysis

The inverses and adjoints calculated by `quoll` can be used for the qualitative analysis of a
system's response to perturbation, as described by Dambacher et al. (2002), and `quoll` provides
some limited functionality to support these analyses.

The `community` function allows a system to be specified symbolically as a directed graph using a
notation similar to that employed by Dambacher et al. (2002), returning the unweighted
community matrix (the signed adjacency matrix of the graph) which can then be visualized with
`community_diagram`.  To specify a signed digraph, the vertices of the graph must first be declared
with the `vertices` directive.  Unidirectional positive relationships between two vertices are
specified with the `%->%` and `%<-%` operators, and unidirectional negative relationships with the
`%-o%` and `%o-%` operators.  Bidirectional relationships are specified with the `%o->%`, `%<-o%`,
`%<->%` and `%o-o%` operators.  Negative self loops can be specified with the loop directive, and
for convenience, when all vertices have a negative self-loop the initial `vertices` directive can be
replaced with a single `loop` directive.

The simple three vertex model is specified as
```{r}
S <- community({
  vertices(1,2,3)
  loop(1)
  1 %o->% 2 %o->% 3
  1 %o->% 3
})
grViz(community_diagram(S))
```

The (unweighted) community matrix (the signed adjacency matrix) for this system is
```{r}
S
```

If the system is stable, the determinant of the negative community matrix is positive, and the
response of the system to a perturbation is determined from the signs of the entries of the adjoint
or inverse of the negative community matrix.

Calculate the adjoint of the *negative* community matrix. The `highlight_ncycle` modifies the
generated LaTeX to highlight cycles with negative weight to assist in identifying the sign of terms.
```{r,results='asis'}
p <- partial(-S,row(S),col(S))
cat("$$",highlight_ncycle(partial_latex(p,type="adj")),"$$",sep="\n")
```
The expressions for an inverse or adjoint have four components.

* The $c_{i}$ are cycle weights - there is one cycle weight for each cycle in the directed graph.
  The cycle that generates a weight can be either read from the table of cycles in the `partial`
  object, or is can be read by reversing the subscripts of the $a_{ij}$ appearing in the cycle
  weight.  For example, the cycle corresponding to $c_{2}$ will be `p$cycles[[2]]`, or can be read
  from the expression $c_{2}=a_{1,2}a_{3,2}a_{3,1}$ as the sequence of edges $1 \to 2$, $2 \to 3$
  and $3 \to 1$.

* The $d_{i}$ are the determinants of the strongly connected components of the directed graph.  If
  the system is stable, then the $d_{i}$ are all positive.  The determinant of the matrix is the 
  product of these terms.

* The $r_{ij}$ are the requested elements of the inverse or adjoint matrix.  Each $r_{ij}$ consists 
  of a sum of terms, each corresponding to a path from vertex $j$ to vertex $i$ in the digraph.  
  These terms are the product of the weights along the path and cyle weights and determinants that
  reflect feedback in the system.  Terms for which total cycle weight is zero are omitted.  The
  path to which a term corresponds can again be read by reversing the subscripts of the $a_{ij}$ 
  that appear in the term.

The expressions generated by `quoll` can often be further algebraically simplified, but are kept in
unsimplified form so that their structure in terms of paths and cycles can be readily identified.
Not all of the $d_{i}$ are required for the calculation of an inverse or adjoint, and the any 
superfluous factors can be suppressed by setting `determinant=FALSE` in the render functions.


## Plankton Bacteria Protozoa Model

The plankton-bacteria-protozoa model of Dambacher et al. (2002) is specified as
```{r}
S <- community({
  loop(R,B,Z,P,N)
  N %<-% R %<-o% B %<-o% N %o->% P %o->% Z %->% N
  P %->% B

})
grViz(community_diagram(S))
```


Calculate the first column of the inverse
```{r}
p <- partial(-S,1:5,1)
```

and render as LaTeX
```{r,results='asis'}
cat("$$",highlight_ncycle(partial_latex(p,type="adj",use.names=TRUE)),"$$",sep="\n")
```

## Custom Render Functions

It is relatively straightforward to write custom render functions to generate code for a new 
language or a specific purpose.

The `partial_components` function constructs the core computational components of the generated 
code.  This function takes as an argument a list that specifies how key syntactic elements of the 
target language are generated, and consists of

* `asub(i,j)`: function to generate code for the i,j element of the weight matrix
* `rsub(i,j)`: function to generate code for the i,j element of the result matrix
* `csub(k)`: function to generate code for the k-th cycle weight variable
* `dsub(k)`: function to generate code for the k-th determinant variable
* `cassign(l,r)`: function to generate code for the assignment of a cycle weight to a variable  
* `dassign(l,r)`: function to generate code for the assignment of a determinant to a variable
* `rassign(l,r)`: function to generate code for the assignment of a result to a variable
* `ratio(n,d)`: function to generate code for the ratio operation
* `mul`: the string for the multiplication operation

The function returns a list with components 

* `cyc`: a named character vector of statements to calculate the cycle weights
* `det`: a named character vector of statements to calculate the determinants
* `el`: a named character vector of statements to calculate the elements of the result matrix.

Each element of these vectors is a single statement in the target language, and is named with the 
variable for which the statement generates a value.  These statements are combined with appropriate
support code to generate the final output.

For example to generate code for an R function that only returns a partial inverse or adjoint matrix
in Fortran 77, we can define the syntactic features for F77 and generate the code components.
```{r}
partial_f77 <- function(partial,type=c("inv","adj"),determinant=TRUE,fname=type) {

  ## Define syntactic features for F77
  fmt <- list(asub=function(i,j) sprintf("A(%d,%d)",i,j),
              rsub=function(i,j) sprintf("R(%d,%d)",i,j),
              csub=function(k) sprintf("C%d",k),
              dsub=function(k) sprintf("D%d",k),
              cassign=function(l,r) sprintf("      %s = %s",l,r),
              dassign=function(l,r) sprintf("      %s = %s",l,r),
              rassign=function(l,r) sprintf("      %s = %s",l,r),
              ratio=function(n,d) sprintf("%s/%s",n,d),
              mul="*")

  ## Generate code components
  code <- partial_components(partial,fmt,type,determinant)

  paste(sprintf("      SUBROUTINE %s(A, R)",toupper(fname)),
        sprintf("      IMPLICIT NONE"),
        sprintf("      DOUBLE PRECISION A(%d,%d), R(%d,%d)",
                nrow(partial$S),ncol(partial$S),nrow(partial$S),ncol(partial$S)),
        sprintf("      DOUBLE PRECISION %s",paste(names(code$cyc),collapse=",")),
        sprintf("      DOUBLE PRECISION %s",paste(names(code$det),collapse=",")),
        "c     Cycle weights",
        paste(code$cyc,collapse="\n") ,
        "c     Determinants",
        paste(code$det,collapse="\n"),
        "c     Elements",
        paste(code$el,collapse="\n"),
        "      RETURN",
        "      END",
        sep="\n")
}
```


For a $3 \times 3$ matrix, `partial_f77` produces
```{r,results='asis'}
S <- matrix(1,3,3)
p <- partial(S,row(S),col(S))
cat("```r",partial_f77(p,type="inv"),"```",sep="\n")
```


### References

Dambacher, J. M., Li, H. W., & Rossignol, P. A. (2002). Relevance of community structure in assessing 
indeterminacy of ecological predictions. *Ecology*, 83(5), 1372-1385.

