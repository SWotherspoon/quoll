---
title: "Validation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Validation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(quoll)
```

The expressions generated by `quoll` for the inverse, adjoint, determinant, and characteristic polynomial
can be validated by comparing them to the numerical results for a random matrix.

```{r}
## Number of replicates
n.rep <- 100
## Matrix size
n <- 6
## Prob of a -1, 0, 1 sign
pr <- c(0.1,0.8,0.1)
```

## Inverse & Adjoint

Compare the expression generated by `partial` to the numerical inverse for $m$ randomly generated 
invertible $n \times n$ matrices.
```{r,fig.show='hold'}
inv.err <- double(n.rep)
adj.err <- double(n.rep)
for(k in seq_len(n.rep)) {
  ## Random invertible matrix
  repeat {
    X <- matrix(sample(-1:1,n^2,replace=TRUE,prob=pr)*runif(n^2,0.01,1),n,n)
    S <- sign(X)
    A <- abs(X)
    if(abs(det(X))>1e-10) break
  }
  ## Partial object
  p <- partial(S,row(S),col(S))
  ## Function for the inverse
  inv <- eval(str2lang(partial_R(p,type="inv"))) 
  ## Function for the adjoint
  adj <- eval(str2lang(partial_R(p,type="adj")))
  ## Compare to the numerical inverse and adjoint
  inv.err[k] <- max(abs(solve(X)-inv(A)))
  adj.err[k] <- max(abs(det(X)*solve(X)-adj(A)))
}
hist(inv.err,xlab="Error",main="Inverse")
hist(adj.err,xlab="Error",main="Adjoint")
```

Check alternate implementation.
```{r,fig.show='hold'}
inv.err <- double(n.rep)
adj.err <- double(n.rep)
for(k in seq_len(n.rep)) {
  ## Random invertible matrix
  repeat {
    X <- matrix(sample(-1:1,n^2,replace=TRUE,prob=pr)*runif(n^2,0.01,1),n,n)
    S <- sign(X)
    A <- abs(X)
    if(abs(det(X))>1e-10) break
  }
  ## Partial object
  p <- partialA(S,row(S),col(S))
  ## Function for the inverse
  inv <- eval(str2lang(partial_R(p,type="inv"))) 
  ## Function for the adjoint
  adj <- eval(str2lang(partial_R(p,type="adj")))
  ## Compare to the numerical inverse and adjoint
  inv.err[k] <- max(abs(solve(X)-inv(A)))
  adj.err[k] <- max(abs(det(X)*solve(X)-adj(A)))
}
hist(inv.err,xlab="Error",main="Inverse")
hist(adj.err,xlab="Error",main="Adjoint")
```



## Determinant

Compare the expression generated by `determinant` to the numerical determinant for $m$ randomly 
generated $n \times n$ matrices.
```{r}
err <- double(n.rep)
for(k in seq_len(n.rep)) {
  ## Random matrix
  X <- matrix(sample(-1:1,n^2,replace=TRUE,prob=pr)*runif(n^2,0.01,1),n,n)
  S <- sign(X)
  A <- abs(X)
  ## Function for the determinant
  d <- partial(S,c(),c())
  detm <- eval(str2lang(determinant_R(d))) 
  ## Compare to the numerical determinant
  err[k] <- det(X)-detm(A)
}
hist(err,xlab="Error",main="Determinant")
```



## Characteristic Polynomial

Evaluate the characteristic polynomial generated by `cpoly` on the numerical eigenvalues
for $m$ randomly generated $n \times n$ matrices.
```{r,fig.show='hold'}
unf.err <- double(n.rep)
fac.err <- double(n.rep)
for(k in seq_len(n.rep)) {
  ## Random invertible matrix
  X <- matrix(sample(-1:1,n^2,replace=TRUE,prob=pr)*runif(n^2,0.01,1),n,n)
  S <- sign(X)
  A <- abs(X)
  ## Coeffs of the unfactored characteristic polynomial
  cp <- cpoly(S,factor=FALSE)
  ucoef <- eval(str2lang(cpoly_R(cp)))
  ## Coeffs of the factored characteristic polynomial
  cp <- cpoly(S,factor=TRUE)
  fcoef <- eval(str2lang(cpoly_R(cp)))
  ## Evaluate at the eigenvalues
  evals <- eigen(X)$values
  unf.err[k] <- max(abs(eval_poly(ucoef(A)$p1,evals)))
  fac.err[k] <- max(abs(Reduce(`*`,lapply(fcoef(A),function(cs) eval_poly(cs,evals)))))
}
hist(unf.err,xlab="Error",main="Unfactored")
hist(fac.err,xlab="Error",main="Factored")
```
